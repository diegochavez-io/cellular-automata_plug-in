---
phase: 03-extract-casimulator
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - plugins/cellular_automata/viewer.py
  - plugins/cellular_automata/__main__.py
autonomous: false
requirements: [SIM-03]

must_haves:
  truths:
    - "python -m cellular_automata coral produces visual output identical to before refactor"
    - "Viewer delegates all simulation to CASimulator — no engine/LFO/advection/containment logic in viewer.py"
    - "All panel callbacks (sliders, preset buttons) work through simulator.set_runtime_params() or simulator attributes"
    - "snap() in __main__.py uses CASimulator instead of duplicated engine creation"
  artifacts:
    - path: "plugins/cellular_automata/viewer.py"
      provides: "Thin pygame display wrapper delegating to CASimulator"
      contains: "self.simulator = CASimulator"
    - path: "plugins/cellular_automata/__main__.py"
      provides: "Simplified snap() using CASimulator"
      contains: "CASimulator"
  key_links:
    - from: "plugins/cellular_automata/viewer.py"
      to: "plugins/cellular_automata/simulator.py"
      via: "self.simulator = CASimulator(preset_key, sim_size)"
      pattern: "self\\.simulator"
    - from: "plugins/cellular_automata/__main__.py"
      to: "plugins/cellular_automata/simulator.py"
      via: "CASimulator import for snap()"
      pattern: "from .simulator import CASimulator"
---

<objective>
Refactor `viewer.py` to be a thin pygame display wrapper that delegates all simulation to `CASimulator` (created in Plan 01). Also simplify `__main__.py` snap() to use CASimulator directly.

Purpose: Complete the extraction by removing duplicated simulation logic from viewer.py and __main__.py. After this plan, viewer.py owns only display/UI, and CASimulator is the single authoritative headless simulation path.

Output: Lean viewer.py (~300-400 lines), simplified __main__.py snap().
</objective>

<execution_context>
@/Users/agi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/agi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-extract-casimulator/03-RESEARCH.md
@.planning/phases/03-extract-casimulator/03-01-SUMMARY.md
@plugins/cellular_automata/viewer.py
@plugins/cellular_automata/simulator.py
@plugins/cellular_automata/__main__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor viewer.py to delegate to CASimulator</name>
  <files>plugins/cellular_automata/viewer.py</files>
  <action>
Refactor `viewer.py` so that `Viewer` is a thin pygame display wrapper. All simulation state and logic has been moved to `CASimulator` in Plan 01 — now remove the duplicated code from viewer.py and wire everything through `self.simulator`.

**Imports to change:**
- Remove engine imports (Lenia, Life, Excitable, GrayScott, CCA, SmoothLife, MNCA) — these are now imported by simulator.py
- Remove `IridescentPipeline` import — owned by simulator
- Remove `SmoothedParameter`, `LeniaParameterCoupler` imports — owned by simulator
- ADD: `from .simulator import CASimulator, FLOW_KEYS, ENGINE_CLASSES, ENGINE_LABELS, FLOW_SLIDER_DEFS`
  (Keep FLOW_SLIDER_DEFS in viewer.py if it's display-only, OR import from simulator — whichever is cleaner)
- Keep `pygame` import (obviously)
- Keep `from .controls import ControlPanel, THEME`
- Keep `from .presets import PRESETS, PRESET_ORDER, PRESET_ORDERS, ENGINE_ORDER, UNIFIED_ORDER, get_preset, get_presets_for_engine`

**Remove from viewer.py module level:**
- `ENGINE_CLASSES` dict (moved to simulator.py)
- `FLOW_KEYS` list (moved to simulator.py; import from simulator)
- `_dilate_world()` function (moved to simulator.py)
- All LFO class definitions: `SinusoidalLFO`, `LeniaLFOSystem`, `GrayScottLFOSystem`, `SmoothLifeLFOSystem`, `MNCALFOSystem`
- `BASE_RES` constant (moved to simulator.py)

**Viewer.__init__() becomes:**
```python
def __init__(self, width=900, height=900, sim_size=1024, start_preset="coral"):
    self.canvas_w = width
    self.canvas_h = height
    self.panel_visible = True
    self.running = True
    self.paused = False
    self.show_hud = True
    self.fullscreen = False
    self.brush_radius = 20
    self.fps_history = []

    # Delegate ALL simulation to CASimulator
    self.simulator = CASimulator(preset_key=start_preset, sim_size=sim_size)

    # Control panel (built after pygame.init in run())
    self.panel = None
    self.sliders = {}
    self.preset_buttons = None
    self._hue_value = 0.25  # Hue slider state (display-side tracking)
```

**Remove all simulation methods from Viewer** (these now live in CASimulator):
- `_rebuild_sim_fields`, `_build_containment`, `_build_noise_mask`, `_build_stir_field`
- `_build_color_offset`, `_build_cca_mask`, `_build_mnca_containment`, `_build_flow_fields`
- `_advect`, `_fast_noise`
- `_drop_center_seed`, `_drop_seed_cluster`, `_drop_center_seed_at`
- `_scale_R`, `_create_engine`, `_apply_preset`
- `_render_gs_emboss`, `_render_frame`, `_apply_bloom`
- All LFO update logic from the run() loop

**Keep in Viewer (display/UI only):**
- `total_w` property
- `_build_panel()` — but update ALL lambda callbacks:
  - Speed slider: `lambda v: setattr(self.simulator, 'sim_speed', v)` (or `self.simulator.set_runtime_params(speed=v)`)
  - Thickness slider: `lambda v: setattr(self.simulator, 'render_thickness', v)`
  - Hue slider: `lambda v: (setattr(self, '_hue_value', v), self.simulator.iridescent.set_hue_offset(v))`
  - Brightness slider: `lambda v: setattr(self.simulator.iridescent, 'brightness', v)`
  - Preset buttons: call `self.simulator.apply_preset(key)` then `self._sync_sliders_from_engine()`
  - Parameter sliders (mu, sigma, T, etc.): update `self.simulator.smoothed_params[key].set_target(v)` or go through `self.simulator.set_runtime_params()`
  - Flow sliders: `lambda v: setattr(self.simulator, '_flow_' + key, v)`
  - Reseed button: call `self.simulator.engine.seed(...)` with preset params
  - All `_make_param_callback()` and `_make_flow_callback()` lambdas: update references from `self.` to `self.simulator.`
- `_sync_sliders_from_engine()` — reads from `self.simulator.engine` and `self.simulator._flow_*` to update slider positions
- `_handle_mouse()` — calls `self.simulator.engine.add_blob(...)` / `remove_blob(...)`
- `_draw_hud()` — reads from `self.simulator.engine` stats
- `_save_screenshot()` — uses current surface
- `run()` — the main event loop, refactored:
  - Remove all inline LFO/advection/containment/coverage logic
  - Replace with: `rgb = self.simulator.step(dt)` to get the frame each tick
  - Convert `rgb` to pygame surface: `pygame.surfarray.make_surface(rgb.swapaxes(0,1).copy())`
  - Keep all pygame event handling, keyboard shortcuts, panel updates
  - Keep FPS calculation and HUD drawing
  - Keep mouse handling, screenshot, pause/resume logic

**Pitfall 4 (CRITICAL):** Every panel callback lambda that used to reference `self.engine`, `self.lfo_system`, `self.smoothed_params`, `self.iridescent`, `self.render_thickness`, etc. must now go through `self.simulator.*`. Missing even one causes AttributeError at runtime.

**Pitfall 5:** `_hue_value` stays in Viewer (slider tracking). Effect goes through `self.simulator.iridescent.set_hue_offset()`.

**Verification approach:** After refactoring, `viewer.py` should NOT contain any of these strings (except in comments):
- `def _advect(`
- `def _build_containment(`
- `def _create_engine(`
- `class SinusoidalLFO`
- `ENGINE_CLASSES = {`
Grep check confirms simulation logic is fully removed.
  </action>
  <verify>
Check that simulation logic is gone from viewer.py:
```bash
cd /Users/agi/Code/daydream_scope && python3 -c "
import re
with open('plugins/cellular_automata/viewer.py') as f:
    content = f.read()
forbidden = ['def _advect(', 'def _build_containment(', 'def _create_engine(',
             'class SinusoidalLFO', 'ENGINE_CLASSES = {', 'def _render_frame(',
             'def _build_flow_fields(', 'class LeniaLFOSystem']
found = [p for p in forbidden if p in content]
if found:
    print(f'FAIL: simulation code still in viewer.py: {found}')
else:
    print('PASS: all simulation logic removed from viewer.py')
"
```

Check that viewer.py uses self.simulator:
```bash
cd /Users/agi/Code/daydream_scope && grep -c 'self\.simulator' plugins/cellular_automata/viewer.py
```
(Should be 15+ references)

Check file size reduction:
```bash
wc -l /Users/agi/Code/daydream_scope/plugins/cellular_automata/viewer.py
```
(Should be ~400-600 lines, down from 1765)
  </verify>
  <done>
  - viewer.py is a thin pygame wrapper (~400-600 lines, down from 1765)
  - All simulation logic delegated through self.simulator
  - Zero simulation methods remain in Viewer class
  - All panel callbacks updated to go through self.simulator
  </done>
</task>

<task type="auto">
  <name>Task 2: Simplify __main__.py snap() to use CASimulator</name>
  <files>plugins/cellular_automata/__main__.py</files>
  <action>
Refactor the `snap()` function in `__main__.py` to use `CASimulator` instead of the current duplicated inline engine creation logic.

**Current snap() problem:** Lines 27-170 in __main__.py duplicate the engine creation, containment, and rendering logic that now lives in CASimulator. This is ~140 lines of copy-pasted code that should be ~15 lines.

**New snap() implementation:**
```python
def snap(preset, sim_size, steps):
    """Headless mode: run N steps, save screenshot, exit."""
    import os
    import numpy as np
    from .simulator import CASimulator
    from .presets import UNIFIED_ORDER

    screenshots_dir = os.path.join(
        os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
        "screenshots"
    )
    os.makedirs(screenshots_dir, exist_ok=True)

    presets_to_snap = [preset] if preset != "all" else UNIFIED_ORDER

    for pkey in presets_to_snap:
        sim = CASimulator(preset_key=pkey, sim_size=sim_size)
        # Run N steps
        dt = 1.0 / 30.0  # ~30fps equivalent
        for i in range(steps):
            rgb = sim.step(dt)

        # Save final frame as PNG
        try:
            from PIL import Image
            img = Image.fromarray(rgb)
        except ImportError:
            # Fallback: save raw with pygame (lazy import)
            import pygame
            pygame.init()
            surf = pygame.surfarray.make_surface(rgb.swapaxes(0, 1).copy())
            path = os.path.join(screenshots_dir, f"snap_{pkey}.png")
            pygame.image.save(surf, path)
            pygame.quit()
            print(f"Saved {path}")
            continue

        path = os.path.join(screenshots_dir, f"snap_{pkey}.png")
        img.save(path)
        print(f"Saved {path}")
```

**Also update the import at the top of __main__.py:**
- Change `from .viewer import Viewer` to remain (still needed for interactive mode)
- The `snap()` function now imports `from .simulator import CASimulator` locally
- Remove the old `from .viewer import ENGINE_CLASSES` import inside snap()

**Keep the rest of __main__.py unchanged** (argument parsing, interactive mode entry).
  </action>
  <verify>
Test headless snap mode:
```bash
cd /Users/agi/Code/daydream_scope && python3 -c "
import sys
sys.modules['pygame'] = None
from plugins.cellular_automata.simulator import CASimulator
sim = CASimulator('coral', 256)
for i in range(10):
    frame = sim.step(0.033)
print(f'snap simulation OK: frame shape={frame.shape}, mean={frame.mean():.1f}')
"
```

Test that __main__.py still works in interactive mode (requires manual verification):
```bash
cd /Users/agi/Code/daydream_scope && python3 -c "
# Just verify the module can be imported without errors
from plugins.cellular_automata.__main__ import snap
print('__main__.py imports OK')
"
```
  </verify>
  <done>
  - snap() uses CASimulator instead of duplicated engine creation logic
  - snap() function is ~30 lines instead of ~140 lines
  - No duplicated containment/engine/rendering code in __main__.py
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Visual verification of refactored viewer</name>
  <action>
Complete Phase 3 refactoring: CASimulator extracted to simulator.py, viewer.py is thin pygame wrapper, __main__.py snap() simplified, IridescentPipeline.render_float() added. User verifies visual parity.
  </action>
  <verify>
1. Run the viewer interactively and verify visual output is identical to before:
   ```bash
   cd /Users/agi/Code/daydream_scope/plugins && python3 -m cellular_automata coral
   ```
2. Cycle through several presets (use preset buttons in panel) — verify each looks correct
3. Test sliders: speed, thickness, hue, brightness — verify they all respond
4. Test keyboard shortcuts: SPACE (pause), R (reseed), TAB (toggle panel)
5. Verify the organism fills the frame, has multi-zone color, background is black
6. Check that all presets produce living, moving organisms (no black/static screens)
  </verify>
  <done>User confirms visual output matches pre-refactor quality with no regressions</done>
</task>

</tasks>

<verification>
1. `python -m cellular_automata coral` runs and produces visual output identical to before refactor
2. All preset buttons work and switch engines correctly
3. All sliders (speed, thickness, hue, brightness, flow fields) respond correctly
4. viewer.py contains no simulation logic (grep check)
5. viewer.py is ~400-600 lines (down from 1765)
6. __main__.py snap() uses CASimulator (no duplicated code)
7. Headless import guard still passes after all changes
</verification>

<success_criteria>
- `python -m cellular_automata coral` produces identical visual output as before Phase 3
- viewer.py is a thin display wrapper delegating to self.simulator
- __main__.py snap() uses CASimulator directly (~30 lines, not ~140)
- All panel callbacks work through self.simulator
- No simulation methods remain in Viewer class
</success_criteria>

<output>
After completion, create `.planning/phases/03-extract-casimulator/03-02-SUMMARY.md`
</output>
