---
phase: 02-iridescent-color-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plugins/cellular_automata/iridescent.py
  - plugins/cellular_automata/viewer.py
autonomous: true

must_haves:
  truths:
    - "Organism surface displays oil-slick iridescent shimmer with cosine palette gradients"
    - "Different parts of organism body show different colors simultaneously (dense interior differs from edges differs from moving regions)"
    - "Entire organism slowly cycles through rainbow colors over time via global hue sweep"
    - "Hue sweep is tied to LFO breathing phase (each breath advances color)"
    - "All four engines (Lenia, Life, Excitable, Gray-Scott) render through the new pipeline"
    - "Performance remains under 22ms/frame at 1024x1024"
  artifacts:
    - path: "plugins/cellular_automata/iridescent.py"
      provides: "IridescentPipeline class with cosine palette rendering, multi-channel signal mapping, global hue sweep"
      exports: ["IridescentPipeline"]
    - path: "plugins/cellular_automata/viewer.py"
      provides: "Viewer using IridescentPipeline instead of ColorLayerSystem"
  key_links:
    - from: "plugins/cellular_automata/viewer.py"
      to: "plugins/cellular_automata/iridescent.py"
      via: "import and instantiation of IridescentPipeline"
      pattern: "from .iridescent import IridescentPipeline"
    - from: "plugins/cellular_automata/viewer.py _render_frame()"
      to: "IridescentPipeline.render()"
      via: "render call passing engine.world and dt"
      pattern: "self\\.iridescent\\.render"
    - from: "IridescentPipeline.render()"
      to: "cosine_palette()"
      via: "multi-channel t parameter drives palette lookup"
      pattern: "cosine_palette"
---

<objective>
Create the iridescent color pipeline and integrate it into the viewer, replacing the 4-layer ColorLayerSystem.

Purpose: This is the core rendering change for Phase 2. The new pipeline uses cosine palette gradients driven by multiple simulation channels (density, edge magnitude, velocity) to produce oil-slick/cuttlefish iridescence. The global hue sweep is tied to LFO breathing phase for organic color animation. All engines render through the same pipeline.

Output: Working `iridescent.py` module and updated `viewer.py` that renders all engines through the new pipeline with visible iridescent shimmer.
</objective>

<execution_context>
@/Users/agi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/agi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-iridescent-color-pipeline/02-CONTEXT.md
@.planning/phases/02-iridescent-color-pipeline/02-RESEARCH.md
@.planning/phases/01-lfo-smoothing/01-01-SUMMARY.md
@plugins/cellular_automata/color_layers.py
@plugins/cellular_automata/viewer.py
@plugins/cellular_automata/engine_base.py
@plugins/cellular_automata/presets.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create iridescent.py — cosine palette pipeline with multi-channel mapping</name>
  <files>plugins/cellular_automata/iridescent.py</files>
  <action>
Create `plugins/cellular_automata/iridescent.py` containing an `IridescentPipeline` class. This replaces the old `ColorLayerSystem` from `color_layers.py`.

**Class: IridescentPipeline**

Constructor `__init__(self, size)`:
- Pre-allocate ALL buffers as float32:
  - `rgb_buffer` (size, size, 3) — working color buffer in linear RGB [0,1]
  - `t_buffer` (size, size) — color parameter field
  - `display_buffer` (size, size, 3) uint8 — final output
  - `edge_buffer` (size, size) — edge magnitude
  - `vel_buffer` (size, size) — temporal velocity
  - `prev_world` — None initially, then (size, size) float32 copy of last frame's world
- Temporal state:
  - `hue_phase` float = 0.0 — accumulated hue rotation in [0, 1] range (wraps)
  - `hue_speed` float = 0.007 — hue advance per frame unit (~143 frames per full cycle, matching old 2.5 deg/sec at 60fps)
- User controls (defaults for good out-of-box look):
  - `tint_r` float = 1.0
  - `tint_g` float = 1.0
  - `tint_b` float = 1.0
  - `brightness` float = 1.0 — exposure multiplier
- Smoothed normalization (anti-strobe, same pattern as old system):
  - `_edge_max_smooth` float = 0.01
  - `_vel_max_smooth` float = 0.01

**Cosine palette presets** — define as module-level dicts with keys a, b, c, d (each np.array of 3 float32). Create several palette presets to be selectable per-preset:
- `"oil_slick"`: a=[0.5, 0.5, 0.5], b=[0.5, 0.5, 0.5], c=[1.0, 1.0, 1.0], d=[0.00, 0.33, 0.67] — classic rainbow iridescence
- `"cuttlefish"`: a=[0.3, 0.5, 0.6], b=[0.4, 0.4, 0.3], c=[1.0, 1.2, 0.8], d=[0.0, 0.25, 0.5] — teal interior, warm edges
- `"bioluminescent"`: a=[0.2, 0.4, 0.5], b=[0.5, 0.5, 0.4], c=[1.5, 1.0, 1.0], d=[0.15, 0.4, 0.6] — deep sea glow
- `"deep_coral"`: a=[0.4, 0.3, 0.5], b=[0.4, 0.5, 0.4], c=[0.8, 1.0, 1.2], d=[0.1, 0.35, 0.55] — warm coral tones
- Store in a dict `PALETTES` at module level
- Default palette: `"cuttlefish"` (best matches the bioluminescent aesthetic goal)

**Method `cosine_palette(self, t, a, b, c, d)`:**
- Implements Inigo Quilez cosine gradient: `color = a + b * cos(2*pi*(c*t + d))`
- t is (H,W), expand to (H,W,1) for broadcasting
- Clip result to [0, 1]
- Write into self.rgb_buffer in-place for performance
- Return self.rgb_buffer

**Method `compute_signals(self, world)`:**
- Computes edge magnitude and velocity from world state (similar to old color_layers.py signals but simplified)
- Edge magnitude: finite differences (roll-based), smoothed max normalization (same anti-strobe pattern: `_edge_max_smooth = max(current, smooth * 0.97)`)
- Velocity: |world - prev_world|, smoothed max normalization
- Stores prev_world copy for next frame
- Writes into pre-allocated edge_buffer and vel_buffer
- Returns (edge_buffer, vel_buffer) tuple

**Method `compute_color_parameter(self, world, edges, velocity)`:**
- Maps simulation state to gradient parameter t in [0, 1]
- Weighted combination: `t = 0.5 * density + 0.3 * edges + 0.2 * velocity`
- density = world normalized to [0,1] (use smoothed max, not instantaneous max, to avoid flickering)
- Result wraps via modulo: `t = t % 1.0`
- Writes into self.t_buffer
- Returns self.t_buffer

**Method `render(self, world, dt, lfo_phase=None)`:**
- Main entry point called each frame
- Steps:
  1. Call compute_signals(world) to get edges and velocity
  2. Call compute_color_parameter(world, edges, velocity) to get t
  3. Advance hue_phase: if lfo_phase is not None, use it to drive hue (hue_phase += hue_speed * dt * 60, so speed is frame-rate independent; ALSO add a small fraction of lfo_phase to create breathing-synchronized color shifts). Otherwise just advance by dt.
  4. Shift the palette d parameter by hue_phase: `d_shifted = palette_d + hue_phase`
  5. Call cosine_palette(t, a, b, c, d_shifted)
  6. Apply ambient glow: where world > 0.001, add a subtle soft haze (multiply rgb by (1 + 0.15 * gaussian_blur_approximation_of_world)). Use a simple approach: `glow = world * 0.12` broadcast to rgb channels. This gives dense areas more luminance, thin edges a translucent feel.
  7. Apply RGB tint as post-render multiplication: `rgb *= [tint_r, tint_g, tint_b]`
  8. Apply brightness as exposure: `rgb *= brightness`  (simple multiplier; gamma/exposure curve can be refined later)
  9. Clip to [0, 1], multiply by 255, cast to uint8 into display_buffer
  10. Return display_buffer

**Method `reset(self, size=None)`:**
- Reset all buffers (on engine change / reseed)
- If size changed, reallocate buffers
- Clear prev_world, reset smoothed maxes

**Method `set_palette(self, palette_name)`:**
- Switch to a different cosine palette preset by name
- Stores current palette name for reference

**CRITICAL design rules (from CONTEXT.md and RESEARCH.md):**
- Color controls are PURELY post-render — NEVER modify engine parameters from color code
- All computation in linear RGB, no gamma correction needed (pygame displays linear fine for this use case — matches old system behavior)
- Pre-allocate ALL buffers in __init__, use in-place operations where possible
- float32 throughout for performance
  </action>
  <verify>
  Run `cd /Users/agi/Code/daydream_scope/plugins && python3 -c "from cellular_automata.iridescent import IridescentPipeline, PALETTES; import numpy as np; p = IridescentPipeline(512); world = np.random.rand(512,512).astype(np.float32); result = p.render(world, 0.016); print(f'Output shape: {result.shape}, dtype: {result.dtype}, range: [{result.min()}, {result.max()}]'); assert result.shape == (512, 512, 3); assert result.dtype == np.uint8; print('PASS: IridescentPipeline works')"` — should print PASS with correct shape and dtype.
  </verify>
  <done>
  `iridescent.py` exists with IridescentPipeline class. Cosine palette rendering produces (H,W,3) uint8 output from simulation world state. Multiple palette presets defined. Multi-channel signal computation (density + edges + velocity) drives spatial color variation. Global hue sweep advances over time. RGB tint and brightness controls implemented as post-render transforms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate IridescentPipeline into viewer.py, remove ColorLayerSystem</name>
  <files>plugins/cellular_automata/viewer.py</files>
  <action>
Modify `plugins/cellular_automata/viewer.py` to use the new IridescentPipeline instead of ColorLayerSystem.

**Import changes:**
- Remove: `from .color_layers import ColorLayerSystem, LAYER_DEFS`
- Add: `from .iridescent import IridescentPipeline`

**Viewer.__init__ changes:**
- Replace `self.layers = ColorLayerSystem(sim_size)` with `self.iridescent = IridescentPipeline(sim_size)`

**Viewer._apply_preset changes:**
- Replace `self.layers.reset(self.sim_size)` with `self.iridescent.reset(self.sim_size)`
- Add palette selection from preset if preset has a `"palette"` key: `if "palette" in preset: self.iridescent.set_palette(preset["palette"])`

**Viewer._on_reset changes:**
- Replace `self.layers.reset()` with `self.iridescent.reset()`
- In auto-reseed block: replace `self.layers.reset()` with `self.iridescent.reset()`

**Viewer._on_clear changes:**
- Replace `self.layers.reset()` with `self.iridescent.reset()`

**Viewer._render_frame — REWRITE completely:**
- Old code computed signals, composited layers, and applied feedback
- New code:
  ```python
  def _render_frame(self, dt):
      """Render using iridescent cosine palette pipeline."""
      # Get LFO phase for hue synchronization (Lenia only)
      lfo_phase = None
      if self.lfo_system:
          lfo_phase = self.lfo_system.mu_lfo.phase

      rgb = self.iridescent.render(self.engine.world, dt, lfo_phase=lfo_phase)
      surface = pygame.surfarray.make_surface(rgb.swapaxes(0, 1).copy())
      return surface
  ```
- Note: Feedback is REMOVED. The old system fed color signals back into the simulation. The new iridescent pipeline is purely visual — no feedback. Remove the feedback section entirely from _render_frame.

**Viewer.run() main loop changes:**
- The call `self.layers.advance_time(dt)` is REMOVED (hue advance now happens inside iridescent.render())
- The call `self._update_swatches()` is REMOVED (no more color swatches)
- Pass `dt` to `_render_frame`: change `sim_surface = self._render_frame()` to `sim_surface = self._render_frame(dt)`

**Viewer._build_panel changes:**
- REMOVE the entire "COLOR LAYERS" section (lines adding layer_0..layer_3 color sliders and feedback slider)
- REMOVE `_make_layer_callback` method
- REMOVE `_update_swatches` method
- The RGB tint and brightness sliders will be added in Plan 02 — for now, the panel just won't have color controls (engine params + LFO + simulation + actions remain)

**Viewer._sync_sliders_from_engine changes:**
- Remove references to layer sliders (layer_0..layer_3, feedback)

**Viewer._save_screenshot changes:**
- Update to use new pipeline: `rgb = self.iridescent.render(self.engine.world, 0.0)` instead of old signals/composite calls

**Remove dead code:**
- Remove import of `LAYER_DEFS` from color_layers
- Remove any remaining references to `self.layers`

**Do NOT delete color_layers.py yet** — that cleanup happens in Plan 02 to keep this plan focused on the swap.
  </action>
  <verify>
  Run `cd /Users/agi/Code/daydream_scope/plugins && python3 -c "from cellular_automata.viewer import Viewer; print('Import OK')"` — should succeed without import errors, confirming viewer.py compiles with the new pipeline.

  Then run visually: `cd /Users/agi/Code/daydream_scope/plugins && timeout 5 python3 -m cellular_automata coral 2>&1 || true` — should start without errors (may time out from pygame window, that's fine). Check for no ImportError, no AttributeError, no missing method errors in output.
  </verify>
  <done>
  Viewer renders all engines through IridescentPipeline. Old ColorLayerSystem references removed from viewer.py. Feedback system removed (color is purely visual now). Hue sweep tied to LFO breathing phase. _render_frame passes dt and lfo_phase to the pipeline. Screenshot uses new pipeline. Panel no longer shows old layer weight sliders.
  </done>
</task>

</tasks>

<verification>
1. Import test: `from cellular_automata.iridescent import IridescentPipeline` succeeds
2. Import test: `from cellular_automata.viewer import Viewer` succeeds (no references to old ColorLayerSystem)
3. Pipeline output: IridescentPipeline.render() returns (H,W,3) uint8 array
4. Visual test: Run `python3 -m cellular_automata coral` — organism displays with iridescent colors, not the old HSV rainbow layers
5. No "self.layers" references remain in viewer.py (grep confirms)
6. Performance: frame time visible in HUD stays under 22ms
</verification>

<success_criteria>
- IridescentPipeline class exists in iridescent.py with cosine palette rendering
- viewer.py uses IridescentPipeline exclusively (no ColorLayerSystem references)
- All four engine types render through the new pipeline
- Organism shows spatial color variation (dense areas, edges, moving regions get different colors)
- Global hue sweep slowly cycles colors over time
- No simulation parameter coupling from color system
- Frame rate maintained (no significant regression)
</success_criteria>

<output>
After completion, create `.planning/phases/02-iridescent-color-pipeline/02-01-SUMMARY.md`
</output>
