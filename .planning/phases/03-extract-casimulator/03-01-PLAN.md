---
phase: 03-extract-casimulator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plugins/cellular_automata/simulator.py
  - plugins/cellular_automata/iridescent.py
autonomous: true
requirements: [SIM-01, SIM-02, SIM-04]

must_haves:
  truths:
    - "CASimulator can be imported and instantiated without pygame installed"
    - "CASimulator.render_float(dt) returns (H,W,3) float32 in [0,1]"
    - "IridescentPipeline.render_float() returns (H,W,3) float32 in [0,1]"
    - "All 4 engine types (lenia, smoothlife, mnca, gray_scott) work through CASimulator"
  artifacts:
    - path: "plugins/cellular_automata/simulator.py"
      provides: "CASimulator class — headless simulation core"
      contains: "class CASimulator"
    - path: "plugins/cellular_automata/iridescent.py"
      provides: "render_float() method on IridescentPipeline"
      contains: "def render_float"
  key_links:
    - from: "plugins/cellular_automata/simulator.py"
      to: "plugins/cellular_automata/iridescent.py"
      via: "self.iridescent = IridescentPipeline(sim_size)"
      pattern: "IridescentPipeline"
    - from: "plugins/cellular_automata/simulator.py"
      to: "plugins/cellular_automata/lenia.py"
      via: "ENGINE_CLASSES dict + _create_engine()"
      pattern: "ENGINE_CLASSES"
    - from: "plugins/cellular_automata/simulator.py"
      to: "plugins/cellular_automata/smoothing.py"
      via: "SmoothedParameter + LeniaParameterCoupler"
      pattern: "SmoothedParameter"
---

<objective>
Create `simulator.py` containing the `CASimulator` class — a headless simulation core extracted from `viewer.py`. Also add `render_float()` to `IridescentPipeline`.

Purpose: `CASimulator` is the prerequisite for the Scope plugin (Phase 4). The Scope plugin will import and call `CASimulator.render_float(dt)` to get frames without any pygame dependency. This plan creates the class; Plan 02 wires viewer.py to delegate to it.

Output: `simulator.py` with working CASimulator, `iridescent.py` with render_float() method.
</objective>

<execution_context>
@/Users/agi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/agi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-extract-casimulator/03-RESEARCH.md
@plugins/cellular_automata/viewer.py
@plugins/cellular_automata/iridescent.py
@plugins/cellular_automata/presets.py
@plugins/cellular_automata/smoothing.py
@plugins/cellular_automata/engine_base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create simulator.py with CASimulator class</name>
  <files>plugins/cellular_automata/simulator.py</files>
  <action>
Create `simulator.py` by extracting ALL simulation logic from `viewer.py`. This is a mechanical lift — move code verbatim, do NOT rewrite algorithms.

**Class interface:**
```python
class CASimulator:
    def __init__(self, preset_key="coral", sim_size=1024):
    def apply_preset(self, key):              # Public preset switch
    def set_runtime_params(self, **kwargs):   # Runtime kwargs (preset, speed, hue, brightness, thickness, reseed)
    def step(self, dt) -> np.ndarray:         # Returns (H,W,3) uint8
    def render_float(self, dt) -> np.ndarray: # Returns (H,W,3) float32 [0,1]
```

**What to move from viewer.py into simulator.py (verbatim):**

1. **Module-level constants and imports** (NO pygame):
   - `import math, time, numpy as np`
   - `from .lenia import Lenia` ... all engine imports
   - `from .iridescent import IridescentPipeline`
   - `from .presets import PRESETS, PRESET_ORDER, ...`
   - `from .smoothing import SmoothedParameter, LeniaParameterCoupler`
   - `try: from scipy.ndimage import gaussian_filter, zoom, maximum_filter, map_coordinates`
   - `FLOW_KEYS` list (define here; viewer.py will import from simulator)
   - `ENGINE_CLASSES` dict
   - `BASE_RES = 512`
   - `_dilate_world()` free function

2. **All LFO class definitions** currently in viewer.py (lines ~155-365):
   - `SinusoidalLFO`
   - `LeniaLFOSystem`
   - `GrayScottLFOSystem`
   - `SmoothLifeLFOSystem`
   - `MNCALFOSystem`

3. **All simulation state from Viewer.__init__** (lines ~380-452) into CASimulator.__init__:
   - `sim_size`, `res_scale`, `sim_speed`, `speed_accumulator`
   - `_prev_mass`, `_stagnant_frames`, `_nucleation_counter`, `_prev_world`, `_perturb_counter`
   - `iridescent = IridescentPipeline(sim_size)`
   - `lfo_system`, `gs_lfo_system`, `sl_lfo_system`, `mnca_lfo_system`
   - `smoothed_params`, `param_coupler`
   - `_containment`, `_noise_mask`, `_noise_pool`, `_noise_idx`, `_color_offset`
   - `_cca_mask`, `_mnca_containment`, `_stir_dx`, `_stir_dy`, `_stir_phase`
   - `_flow_fields`, `_flow_base_y`, `_flow_base_x`, `_flow_adv_y`, `_flow_adv_x`
   - All `_flow_*` attribute values (from FLOW_KEYS loop)
   - `preset_key`, `engine_name`, `engine`
   - `render_thickness = 0.0` (initialize BEFORE _apply_preset to avoid AttributeError — see Pitfall 2)
   - Call `self._apply_preset(preset_key)` at end of __init__

4. **All simulation methods from Viewer** (move verbatim):
   - `_rebuild_sim_fields()` (line 458)
   - `_build_containment()` (line 479)
   - `_build_noise_mask()` (line 492)
   - `_build_stir_field()` (line 504)
   - `_build_color_offset()` (line 524)
   - `_build_cca_mask()` (line 566)
   - `_build_mnca_containment()` (line 582)
   - `_build_flow_fields()` (line 595)
   - `_advect()` (line 668)
   - `_fast_noise()` (line 714)
   - `_drop_center_seed()` (line 719)
   - `_drop_seed_cluster()` (line 757)
   - `_drop_center_seed_at()` (line 777)
   - `_scale_R()` (line 804)
   - `_create_engine()` (line 808)
   - `_apply_preset()` (line 880)
   - `_render_gs_emboss()` (line 1206)
   - `_render_frame()` (line 1292)
   - `_apply_bloom()` (line 1362)

5. **step() method** — extract the simulation loop body from `Viewer.run()` (lines ~1462-1765). The `step(dt)` method must contain:
   - Smoothed parameter updates
   - LFO update → engine parameter setting (ALL four engine types: Lenia, GS, SL, MNCA)
   - Speed accumulator + engine.step() loop
   - After each engine step: advection (with GrayScott dual-world: U+V both advected — Pitfall 1), containment, stir/noise/perturbation
   - Coverage management: mass tracking, stagnation detection, nucleation, anti-stagnation reseed
   - Velocity-driven perturbation
   - Frame rendering via _render_frame()
   - Return uint8 RGB array

6. **render_float(dt)** — calls `step(dt)` and converts:
   ```python
   def render_float(self, dt):
       rgb_uint8 = self.step(dt)
       return rgb_uint8.astype(np.float32) / 255.0
   ```

7. **set_runtime_params()** — handle runtime kwargs:
   - `preset`: call `self.apply_preset(val)`
   - `speed`: set `self.sim_speed`
   - `hue`: call `self.iridescent.set_hue_offset(val)`
   - `brightness`: set `self.iridescent.brightness`
   - `thickness`: set `self.render_thickness`
   - `reseed`: call `self.engine.seed(...)` with preset seed params
   - Flow keys: set `self._flow_{key}` values

**CRITICAL pitfalls to honor:**
- Pitfall 1: GrayScott dual-world advection — advect BOTH `engine.U` and `engine.V`, then clip both, then `engine.world = engine.V`
- Pitfall 2: Initialize `self.render_thickness = 0.0` in `__init__` BEFORE `_apply_preset()`
- Pitfall 6: Initialize `self._prev_world = None` in `__init__`
- Pitfall 7: `ENGINE_CLASSES` must be defined in simulator.py
- Pitfall 8: `FLOW_KEYS` defined in simulator.py (viewer.py will import it)

**ZERO pygame imports** — verify the entire import chain is pygame-free.
  </action>
  <verify>
Run headless import guard test:
```bash
cd /Users/agi/Code/daydream_scope && python3 -c "
import sys, numpy as np
sys.modules['pygame'] = None
from plugins.cellular_automata.simulator import CASimulator
sim = CASimulator('coral', 512)
frame = sim.render_float(0.016)
assert frame.shape == (512, 512, 3), f'Wrong shape: {frame.shape}'
assert frame.dtype == np.float32, f'Wrong dtype: {frame.dtype}'
assert 0.0 <= frame.min() and frame.max() <= 1.0, 'Out of range'
print('SIM-02 PASS: pygame-free import chain confirmed')
"
```

Then test all 4 engine types:
```bash
cd /Users/agi/Code/daydream_scope && python3 -c "
import sys, numpy as np
sys.modules['pygame'] = None
from plugins.cellular_automata.simulator import CASimulator
for preset in ['coral', 'medusa', 'reactor', 'mitosis']:
    sim = CASimulator(preset, 256)
    for _ in range(5):
        frame = sim.step(0.016)
    assert frame.shape == (256, 256, 3)
    assert frame.dtype == np.uint8
    print(f'{preset}: OK (mean={frame.mean():.1f})')
print('All engines pass')
"
```
  </verify>
  <done>
  - `simulator.py` exists with `CASimulator` class
  - Headless import guard passes (sys.modules['pygame'] = None + import succeeds)
  - `render_float()` returns (H,W,3) float32 [0,1]
  - All 4 engines (lenia, smoothlife, mnca, gray_scott) produce non-zero frames through CASimulator
  </done>
</task>

<task type="auto">
  <name>Task 2: Add render_float() to IridescentPipeline</name>
  <files>plugins/cellular_automata/iridescent.py</files>
  <action>
Add a `render_float()` method to the `IridescentPipeline` class in `iridescent.py`. This is a thin wrapper over the existing `render()` method that returns float32 instead of uint8.

Add this method right after the existing `render()` method:

```python
def render_float(self, world, dt, lfo_phase=None, color_weights=None, t_offset=None):
    """Render and return (H, W, 3) float32 [0, 1].

    Thin wrapper over render() that converts uint8 output to float32.
    Creates a new array (caller owns the data; display_buffer is reused each frame).

    Args: same as render()
    Returns: (H, W, 3) float32 array in [0, 1]
    """
    rgb_uint8 = self.render(world, dt, lfo_phase=lfo_phase,
                            color_weights=color_weights, t_offset=t_offset)
    return rgb_uint8.astype(np.float32) / 255.0
```

NOTE: The `CASimulator.render_float()` on the simulator calls the full frame render path (GS emboss, bloom, thickness dilation, engine-specific preprocessing) and then converts to float32. The `IridescentPipeline.render_float()` here is a utility method that wraps just the iridescent color render. Both serve different purposes — the SIM-04 requirement is for IridescentPipeline to have this method, but the Scope plugin will call CASimulator.render_float().
  </action>
  <verify>
```bash
cd /Users/agi/Code/daydream_scope && python3 -c "
import numpy as np
from plugins.cellular_automata.iridescent import IridescentPipeline
pipe = IridescentPipeline(256)
world = np.random.rand(256, 256).astype(np.float32)
result = pipe.render_float(world, 0.016)
assert result.shape == (256, 256, 3), f'Wrong shape: {result.shape}'
assert result.dtype == np.float32, f'Wrong dtype: {result.dtype}'
assert 0.0 <= result.min() and result.max() <= 1.0, 'Out of range'
print('SIM-04 PASS: IridescentPipeline.render_float() works')
"
```
  </verify>
  <done>
  - `IridescentPipeline` has `render_float()` method
  - Returns (H,W,3) float32 [0,1]
  - Creates new array (not a view of display_buffer)
  </done>
</task>

</tasks>

<verification>
1. Headless guard test passes:
   ```bash
   python3 -c "import sys; sys.modules['pygame'] = None; from plugins.cellular_automata.simulator import CASimulator; print('PASS')"
   ```

2. CASimulator.render_float() returns correct format:
   ```bash
   python3 -c "
   import sys, numpy as np
   sys.modules['pygame'] = None
   from plugins.cellular_automata.simulator import CASimulator
   sim = CASimulator('coral', 512)
   f = sim.render_float(0.016)
   assert f.shape == (512,512,3) and f.dtype == np.float32
   print('render_float OK')
   "
   ```

3. IridescentPipeline.render_float() returns correct format:
   ```bash
   python3 -c "
   import numpy as np
   from plugins.cellular_automata.iridescent import IridescentPipeline
   p = IridescentPipeline(256)
   f = p.render_float(np.random.rand(256,256).astype(np.float32), 0.016)
   assert f.shape == (256,256,3) and f.dtype == np.float32
   print('IridescentPipeline.render_float OK')
   "
   ```

4. All 4 engine types produce living frames (non-zero output) through CASimulator after 5 steps.
</verification>

<success_criteria>
- `simulator.py` exists with `CASimulator` class containing all simulation logic
- Zero pygame imports in simulator.py or its import chain
- `CASimulator('coral', 512).render_float(0.016)` returns (512,512,3) float32 [0,1]
- All 4 engine types (lenia, smoothlife, mnca, gray_scott) work through CASimulator
- `IridescentPipeline.render_float()` exists and returns correct format
</success_criteria>

<output>
After completion, create `.planning/phases/03-extract-casimulator/03-01-SUMMARY.md`
</output>
